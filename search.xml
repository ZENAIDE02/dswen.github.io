<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>在搭建 blog 过程中发现的 cdn 与图片问题</title>
    <url>/2020/10/30/%E5%9C%A8%E6%90%AD%E5%BB%BA-blog-%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%8E%B0%E7%9A%84-cdn-%E4%B8%8E%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>离散数学两道重思考</title>
    <url>/2020/11/15/discrete-mathematical-experiment/</url>
    <content><![CDATA[<h3 id="命题逻辑推理"><a href="#命题逻辑推理" class="headerlink" title="命题逻辑推理"></a>命题逻辑推理</h3><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>根据下面的命题，使用命题逻辑推理的方法确定谁是作案者，写出推理过程。<br>一个公安人员审查一件盗窃案，已知的事实如下：<br>（1）A或B盗窃了x;<br>（2）若A盗窃了x，则作案时间不能发生在午夜前；<br>（3）若B证词正确，则在午夜时屋里灯光未灭；<br>（4）若B证词不正确，则作案时间发生在午夜前；<br>午夜时屋里灯光灭了；</p>
<h4 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h4><ol>
<li>符号化上面的命题，将它们作为条件，B盗窃了x作为结论，得到一个复合命题；</li>
<li>将复合命题中用到的联结词定义成python语言的函数，用变量表示相应的命题变元。将复合命题写成一个函数表达式。</li>
<li>函数表达式中的变量赋初值1。如果函数表达式的值为1，则结论有效，A盗窃了x，否则B盗窃了x。</li>
</ol>
<h4 id="命题符号化"><a href="#命题符号化" class="headerlink" title="命题符号化"></a>命题符号化</h4><p>L：午夜灯光灭了；B：B的证词正确；<br>N：作案时间发生在午夜前；<br>T（y）：y盗窃了x；<br>（T（B）∨N）∧（！B∨L）∧（B∨！N）→T（B）</p>
<p>代码实现如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">    if a==True:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">def r(b,N,L,B):</span><br><span class="line">    s=(f((b or N)and(f(b)or L)and(B or f(N)))or b)</span><br><span class="line">print(r(1,1,1,1))</span><br></pre></td></tr></table></figure></div>

<h3 id="旅行路线规划问题"><a href="#旅行路线规划问题" class="headerlink" title="旅行路线规划问题"></a>旅行路线规划问题</h3><h4 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4><p>加深图的汉密尔顿路及最短路径的理解与应用，将汉密尔顿图与生活实例结合在一起。</p>
<p>选取了大学所在地沈阳为旅游城市。经过从网上查看相关旅游报告及数据，选取了八个热门旅游景点。分别是沈阳故宫（C1），中街（C2），沈阳世博园（C3），沈阳方特欢乐世界（C4），沈阳森林动物园（C5），清昭陵（C6），关东影视城（C7），棋盘山（C8）。选取游客到达沈阳后所居住酒店选取最近的景点作为出发点，即随机起点，通过汉密尔顿图相关知识的运用，推算出走遍所有景点最合理的路径。</p>
<!-- ![沈阳路径图](./assets/img/discrete-mathematical-experiment/shenyang_road.png "Hamilton Road") -->
<!-- ![沈阳路径图](./assets/img/discrete-mathematical-experiment/shenyang_road.png "Hamilton Road") -->
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/discrete-mathematical-experiment/shenyang_road.png"
                      alt="沈阳路径图" title="Hamilton Road"
                ></p>
<h4 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h4><ol>
<li>首先，经过从网上查看相关旅游报告及数据，我选取了八个热门旅游景点。分别是沈阳故宫（C1），中街（C2），沈阳世博园（C3），沈阳方特欢乐世界（C4），沈阳森林动物园（C5），清昭陵（C6），关东影视城（C7），棋盘山（C8）。结合搜索的旅游心理调研报告，发现人们在景点的选取上考虑的距离，交通价格，时间等等。因考虑到公共交通工具的时间成本不固定等因素，权重表里的时间及价格皆为打车或自驾游。根据调研报告显示的比重，决定用距离<em>0.5+时间</em>0.3+价格*0.2作为两景点之间的权重。</li>
<li>根据权重表画出汉密尔顿图，将实际地图抽象化为以下模型。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/discrete-mathematical-experiment/shenyang_road_model.png"
                      alt="沈阳路径模型图" title="shenyang_road_model"
                ></li>
<li>构建模型，经过对问题的分析，决定最终算法。用C语言进行编程，得到了最短路径。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/discrete-mathematical-experiment/shenyang_road_C_solution.png"
                      alt="沈阳路径算法解决图" title="shenyang_road_C_solution"
                ></li>
<li>利用代码运行结果得到了最短的汉密尔顿回路：“沈阳故宫→中街→清昭陵→棋盘山→沈阳森林动物园→沈阳方特欢乐世界→沈阳世博园→关东影视城”，成功地解决了最短路径的问题。</li>
</ol>
<h4 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h4><ol>
<li>首先是问题的提出方面，选择了沈阳是便于在大学生活中将这一实验成果真正运用，而具体景点的选取则是按照旅游景点热榜自高到低选取了前八位的景点使其最具有代表性。</li>
<li>在权重的处理方面，则是通过与相关调查结果综合给定比例，综合考虑到距离，时间，交通成本等多方面因素，从而使获得数据更为可靠精确。而这一机械运算过程通过Excel的功能可以较为轻松地实现，体现了多元应用数据处理工具的重要作用，同时也提高了工作效率。</li>
<li>在数据获取方面，采用了百度地图的智行算法。把每两个景区之间的路径抽象为智行建议规划出的路径，并为了控制变量均选用此标准。而且在智行的推荐中恰好提供了两地之间交通的估计时间与使用交通工具的花销，即成本，在对时间进行四舍五入，保留一位小数的处理后，存入表格。使得距离时间等数据更加真实可靠。</li>
<li>考虑到算权重最小值将会是一个比较繁琐的工作量，而且适用于景点较少的旅行图中。如果景点很多，算权重的方法将显得笨拙而不适用。因此，我们采用了用代码实现这一过程的形式，这样有较大的可维护空间，距离时间等量的改变也不会对工作造成很大的影响，具有一定的稳定性。</li>
</ol>
<h4 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a>遇到的问题和解决方案</h4><ol>
<li>本次实验中遇到的第一个问题是权重的量化比例的确定。为了使权重比例更加符合人们的旅游习惯和思维方式，我去查阅了相关资料，拟定了时间和成本加权获得权重值这一方法，这种方法使得获得的数据更为实用化，更有助于现实生活中问题的解决。</li>
<li>代码算法的确定。因为以前没有接触过求最短路径的问题，所以不知道该采用什么样的算法会使得整个的代码过程变得简洁可维护。小组在开始时决定利用算法，将所有的汉密尔顿回路求出，并遍历这些回路，最终得到最短路径。但这些数据路径会偏多，虽然思路简单但是并不太适合景点数量非常多的时候。经过代码的不同形式的确定，以及查阅了一些常用的求最短回路的算法，我们才确定了本次实验所使用的代码过程。</li>
</ol>
<h4 id="心得总结"><a href="#心得总结" class="headerlink" title="心得总结"></a>心得总结</h4><p>这个问题让我更加理解了汉密尔顿图以及带权图等图论的知识点和应用，不仅使我在课堂上学的知识更加牢固，而且加强了我利用理论知识解决生活中实际问题的能力，让我感受到离散数学在生活中的重要作用。另外，此次还锻炼了我利用编程工具实现一个能帮助我们在实际生活中对一些问题进行快速解决的工具。我深刻认识到代码编程在解决问题中的重要作用以及效率之大，解决了一些用人力繁琐计算的问题。今后学习算法设计时，也要多考虑实际的应用场景。</p>
]]></content>
  </entry>
  <entry>
    <title>软件需求规格说明与设计</title>
    <url>/2020/11/25/software-requirement-analysis/</url>
    <content><![CDATA[<h3 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h3><p>对于软件需求说明，我认为不仅要学习系统知识，还应该深入某个案例具体分析，所以我们结合自身所接触，最终选取了高校调查问卷管理系统，进行系统应用。</p>
<p>本系统是高校调查问卷管理系统，由问卷设计人员设计调查问卷，导入师生信息后发送问卷链接到个人邮箱，从学生和教师获知其对学校、专业、教学情况、教学资源配套、学校管理水平等多方面评价的信息收集，填写完成后问卷数据存储至数据库，由系统对数据整合后，可查询数据进行数据分析汇报。</p>
<ul>
<li>业务需求：</li>
</ul>
<ol>
<li>系统能够设计并发布自定义数量和多种题目类型（包括单项选择题、多项选择题、填空题的问卷，并提供问卷设计模板与参考题库，问卷数据可以存储至数据库</li>
<li>系统能够导入待问卷人员（包括学生、教师）的信息，并检索信息格式和信息空缺。</li>
<li>系统能够通过短信、邮件的方式将问卷链接发布至待问卷人员的手机或者<br>邮箱中。</li>
<li>系统能够将待问卷人员的填写数据添加到系统数据库中。</li>
<li>系统能够对问卷结果进行统计分析，查询时可以以图表方式（折线，柱状图等等）可视化，并导出到本地文件。</li>
</ol>
<ul>
<li>功能需求：</li>
</ul>
<ol>
<li>   问卷设计:问卷设计人员由问卷模板设置问题完成问卷设计</li>
<li>   问卷发布：问卷发布人员根据导入的邮箱（优先级高）和电话号码（第二选择）将问卷链接发布给待问卷人员</li>
<li>   问卷填写：填写完成问卷后提交，数据保存至数据库</li>
<li>   数据查询：政府人员和校方对问卷结果进行查询，分析反映的问题。</li>
</ol>
<h3 id="编写目的"><a href="#编写目的" class="headerlink" title="编写目的"></a>编写目的</h3><ul>
<li>便于用户、开发人员进行理解和交流。 </li>
<li>反映出用户问题的结构，可以作为软件开发工作的基础和依据。 </li>
<li>提高软件开发过程的能见度。把开发过程中发生的事件以某种可阅读的形式记录在文档中。</li>
<li>作为开发人员在一定阶段的工作成果和结束标志。 </li>
<li>记录开发过程中的有关信息，便于协调以后的软件、开发、使用和维护。</li>
</ul>
<h3 id="读者对象"><a href="#读者对象" class="headerlink" title="读者对象"></a>读者对象</h3><ul>
<li>设计员：根据架构对软件系统进行复杂度分析，使成本收益最大化。</li>
<li>程序员：根据架构对系统进行优化。</li>
<li>测试员：根据交互模型，对软件产品进行功能性测试和非功能性测试，记录反馈存在的问题。</li>
<li>用户：了解预期产品的功能和性能。</li>
</ul>
<h3 id="架构设计目标和约束"><a href="#架构设计目标和约束" class="headerlink" title="架构设计目标和约束"></a>架构设计目标和约束</h3><h4 id="架构设计目标"><a href="#架构设计目标" class="headerlink" title="架构设计目标"></a>架构设计目标</h4><p>架构设计的目标是将系统分析阶段所提出的反映用户需求的系统逻辑方案转换成可以实施的基于计算机与通信系统的物理方案，为后续系统开发提供指导和依据。通过架构设计，将系统分为几个模块，确定每个模块的功能以及每个模块之间的关联。对每个模块进行详细的类设计，使模块能够完整的描述系统功能。</p>
<p>架构设计的主要目的是为了分析软件复杂度，解决软件系统复杂度带来的问题。优秀的架构设计能更好的收益最大化。</p>
<h4 id="约束需求"><a href="#约束需求" class="headerlink" title="约束需求"></a>约束需求</h4><ul>
<li>软件质量约束：</li>
</ul>
<ol>
<li>调查表应该通过打开链接在浏览器上进行填写。</li>
<li>在一次提交过后不可以重新提交，除非发布问卷方再次发送问卷。</li>
<li>需要区分使用权限，高级权限可以进行问卷编辑和查看所有用户的数据，但低级权限只能查看指定范围的数据。</li>
<li>通过号码或者邮箱发送只选择其中一个，邮箱的优先级更高，因为短信发送可能会被当作垃圾短信屏蔽。</li>
<li>当为匿名调查表模式时，个人信息在查询时不可见，仅能在数据库中查询。</li>
<li>填写时，数据随时保存至服务器，做到及时保存，防止数据丢失。</li>
<li>问题数量应该有限制，问题不能在一页显示完时，规定翻页式</li>
<li>如果数据汇总时有数据缺失或者不符合要求，在查询时应该列出该数据，并在数据统计时排除在外。</li>
<li>如果两种方式都无法发送问卷，则标记该数据为未发送</li>
<li>如果数据出错的问卷数量过多，需要进行报备，列出出错的问卷，并定位出错的问卷填写者，进行二次发送问卷。</li>
<li>严格权限访问控制，用户在经过身份认证后，只能访问其权限范围内的数据，只能进行其权限范围内的操作。</li>
<li>降低代码与代码之间的耦合，使得能够更容易地进行功能地扩展。建立高内聚，低耦合模块。使用结构化程序设计技术，提高现有系统的可维护性。</li>
</ol>
<ul>
<li>安全性约束：</li>
</ul>
<ol>
<li>能经受来自互联网的一般性恶意攻击。如病毒（包括木马）攻击、口令猜测攻击、黑客入侵等。至少99%的攻击需要在10秒内检测到。</li>
<li>程序出现异常后，要及时报警，要有补救措施，报警可以发送给人，也可以发送给系统自动处理，如：服务降级、自动重启等。</li>
<li>只有授权的用户才能动用和修改数据库中学生和教师的个人信息，而且必须防止信息的非法、非授权的泄漏。</li>
</ol>
<ul>
<li>用户界面的约束：<br>界面简洁美观，布局统一，易于用户理解和操作。</li>
</ul>
<h3 id="系统总体设计"><a href="#系统总体设计" class="headerlink" title="系统总体设计"></a>系统总体设计</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>整个问卷系统采用三层架构的模式，分为用户界面层——业务逻辑层——数据访问层三层。<br>用户界面层主要包含主要的功能界面管理设定，包括登录注册，问卷设计，问卷填写，数据查询。业务逻辑层采用的是外观设计模式。创建实体类接收来自界面层的访问请求，并分别调用问卷编辑端，问卷填写端，后台端中的子系统进行数据请求的处理。<br>数据访问层以数据库为主，保存客户信息和问卷信息，同时对数据库要有能够实现增删改查等操作的工具类，负责存储数据以及对外发送数据的功能。</p>
<h4 id="软件逻辑架构设计"><a href="#软件逻辑架构设计" class="headerlink" title="软件逻辑架构设计"></a>软件逻辑架构设计</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/model_design.png"
                      alt="软件逻辑架构设计" title="软件逻辑架构设计"
                ></p>
<p>视图层：用来存储相关的页面，负责向用户展现系统信息、反馈数据，以及获取用户操作和请求。其中包括查询结果，登录注册，问卷设计发布，问卷填写等相关的界面。<br>业务逻辑层：进行逻辑的代码编写。主要以三个功能为主体进行，分为三个端口，问卷编辑端，问卷填写端和发布端，端口中的子系统进行请求的处理。数据访问层：其中主要存储了系统所需要的相关数据，如待问卷人员的基本信息，管理人员的登录信息，问卷回收时所收集到的问卷的内容信息。并随时等待业务逻辑层的调用。<br>实体类则放置了系统运行所需要的所有的实体类以及其主要的属性：数据分析人员/问卷发布人员（管理人员的登录用户名密码等），待问卷人员（基本信息以及联系方式）以及做好后发布的问卷（问卷问题的集合）和提交后的问卷（填写的问卷数据）。</p>
<h4 id="系统主要业务流程设计"><a href="#系统主要业务流程设计" class="headerlink" title="系统主要业务流程设计"></a>系统主要业务流程设计</h4><table>
<thead>
<tr>
<th>标题</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>用例名称</td>
<td>设计调查问卷</td>
</tr>
<tr>
<td>用例简要说明</td>
<td>根据问卷调研出的问卷需求允许政府账号对问卷进行设计</td>
</tr>
<tr>
<td>前置条件</td>
<td>该账号拥有系统识别的高级权限</td>
</tr>
</tbody></table>
<p>事件流：（1）基本流 当政府账号登陆成功决定设计调查问卷的时候用例开始<br>①政府或者校方登陆系统<br>②系统判断用户权限等级，高权限级别进行问卷设计，低权限事件流结束<br>（2）备选流<br>①进行问卷设计，选择新建项目或者在工作台编辑未完成的缓存项目<br>②如果选择新建项目，则选择一个模板进行设计<br>③进行问题类型的选择和设计，分为选择题和填空题<br>④问卷未完成退出系统会保存当前编辑状态并存储至工作台，若完成则保存问卷等待发送，移出工作台<br>（3）异常流<br>用户登录使用的账号不存在，提示注册或者更换账号登录。<br>登录密码错误提示重新输入，输错5次后会锁定10分钟<br>后置条件    问卷保存在系统中等待校方信息录入后进行发布<br>扩展点    根据问卷设计者选择的问卷主题提供对应的题库进行参考<br>优先级    高</p>
<p>设计调查问卷交互图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/questionnaire_interaction_diagram.jpg"
                      alt="设计调查问卷交互图" title="设计调查问卷交互图"
                ></p>
<p>导入学生和教师数据交互图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/data_transfer.jpg"
                      alt="导入学生和教师数据交互图" title="导入学生和教师数据交互图"
                ></p>
<p>发布问卷交互图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/questionnaire_publish.jpg"
                      alt="发布问卷交互图" title="发布问卷交互图"
                ></p>
<h3 id="功能模块划分"><a href="#功能模块划分" class="headerlink" title="功能模块划分"></a>功能模块划分</h3><h4 id="模块-描述"><a href="#模块-描述" class="headerlink" title="模块-描述"></a>模块-描述</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/module_description.png"
                      alt="模块描述" title="模块描述"
                ></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块功能（职责）概述</th>
</tr>
</thead>
<tbody><tr>
<td>问卷处理模块</td>
<td>对问卷进行基本操作的功能模块，根据用户点击界面获得的请求信息，调用模块中对应的子系统对问卷进行对应的操作</td>
</tr>
<tr>
<td>信息数据管理模块</td>
<td>此模块包含系统的各种数据库文件以及维护，主要功能是存储系统的各项数据内容（用户信息，问卷信息）、对数据进行维护、以及对外界请求发生数据的功能。当用户请求访问数据时，返回被访数据</td>
</tr>
<tr>
<td>信息查询模块</td>
<td>此模块是中介模块，负责处理用户访问数据的请求，判断是否允许该请求查询数据和处理数据请求的范围，并传递给信息数据管理模块进行具体操作</td>
</tr>
<tr>
<td>用户界面模块</td>
<td>此模块包含所有的用户界面，根据登陆人员的权限跳转到不同的用户界面，更具界面点击获得的反馈跳转到各个功能界面</td>
</tr>
</tbody></table>
<h4 id="模块-接口设计"><a href="#模块-接口设计" class="headerlink" title="模块-接口设计"></a>模块-接口设计</h4><ol>
<li>用户界面模块: 此模块的接口需要和信息数据管理系统对接，获取信息，然后调用正确的界面。用户类User,接收参数为String username,String password。用户未注册时首先进行注册，注册成功后将用户信息传递到数据库中，注册成功后根据匹配数据库中的用户信息进行登录并跳转到不同权限用户的管理界面，在信息管理系统中可以对用户信息进行增删改查操作。</li>
<li>问卷处理模块：包括问卷设计Designer和问卷发布Publisher。<br>问卷设计Designer接收参数为Questionnaire Questionnaire,可以获得问卷设计的数量，对问卷进行增删改查等操作。问卷发布Publisher接收参数为Que Questionnaire,用来确认是否发布问卷以及问卷是否终止。</li>
<li>信息查询模块：此模块接口接受问卷处理模块和界面模块的数据查询请求，处理后传递给信息数据管理模块打开对应的系统。</li>
<li>信息数据管理模块：包括用户信息管理，问卷数据管理Analyst和<br>待问卷人员信息管理Responder。用户信息管理将会在用户注册之后将用户信息存储在数据库中，问卷数据管理Analyst接收参数为Q Questionnaire,接受问卷调查人员所填的问卷，判断问卷是否合规，将符合规范的问卷进行分析并将结果显示在高权限用户人员的界面中。</li>
</ol>
<h3 id="系统概念架构设计"><a href="#系统概念架构设计" class="headerlink" title="系统概念架构设计"></a>系统概念架构设计</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/system_conceptual_architecture_design.png"
                      alt="系统概念架构设计" title="系统概念架构设计"
                ></p>
<h3 id="数据库逻辑架构设计"><a href="#数据库逻辑架构设计" class="headerlink" title="数据库逻辑架构设计"></a>数据库逻辑架构设计</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/software-requirement-analysis/sql_design.png"
                      alt="数据库逻辑架构设计" title="数据库逻辑架构设计"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理实验</title>
    <url>/2020/11/28/computer-composition-principle-experiment/</url>
    <content><![CDATA[<p>整理了一下计组最后的两个实验。</p>
<h3 id="指令-微指令设计实验"><a href="#指令-微指令设计实验" class="headerlink" title="指令/微指令设计实验"></a>指令/微指令设计实验</h3><p>COP2000计算机组成原理实验仪，可以由用户自己设计指令/微指令系统，这样用户可以在现有的指令系统上进行扩充，加上一些较常用的指令，也可重新设计一套完全不同的指令/微指令系统。</p>
<p>因为硬件系统需要指令机器码的最低两位做为R0-R3寄存器寻址用，所以指令机器码要忽略掉这两位。这四条指令的机器码分别为04H，08H，0CH，10H。其它指令的设计相同。</p>
<p>程序开始要执行的第一条微指令应是取指操作，因为程序复位后，PC和uPC的值都为0，所以微程序的0地址处就是程序执行的第一条取指的微指令。根据此功能，首先选中“_FATCH_”指令的第一行，观察窗口下方的各控制信号，有“勾”表示信号为高，处于无效状态，去掉“勾”信号为低，为有效状态。要从EM中读数，EMRD必需有效，去掉信号下面的“勾”使其有效；读EM的地址要从PC输出，所以PCOE要有效，允许PC输出，去掉PCOE下面的“勾”，PCOE有效同时还会使PC加1，准备读EM的下一地址；IREN是将EM读出的指令码存入uPC和IR，所以要去掉IREN的“勾”使其有效。这样，取指操作的微指令就设计好了，取指操作的微指令的值为0CBFFFFH。</p>
<p>第一条指令是把立即数装入累加器A，首先要从EM中读出立即数，并送到数据总线DBUS，再从DBUS上将数据打入累加器A中，按照这个要求，从EM中读数据，EMRD应该有效，EM的地址由PC输出，PCOE必需有效，读出的数据送到DBUS，EMEN也应有效,要求将数据存入A中,AEN也要有效，选中“LD  A，#II”指令的第一行，这条微指令的值为0C7FFF7H。为了保证程序的连续执行，每条指令的最后必需是取指令，取出下条将要执行的指令。所以微指令的值为0CBFFFFH。</p>
<p>第二条指令为立即数加法指令，立即数加可分两步，首先从EM中读出立即数，送到DBUS，并存入工作寄存器W中，从EM中读数，EMRD应有效，读EM的地址由PC输出，PCOE要有效，读出的数据要送到DBUS，EMEN应有效，数据存入W中，WEN应有效，根据描述，这条微指令的值为0C7FFEFH。第二步，执行加法操作，并将结果存入A中。执行加法操作，S2S1S0的值应为000(二进制)，结果无需移位直接输出到DBUS，X2X1X0的值就要为100(二进制)，从DBUS将数据再存入A中，AEN应有效。与此同时，ABUS和IBUS空闲，取指操作可以并行执行，也就是以PC为地址，从EM中读出下条将要执行指令的机器码，并打入IR和uPC中，根据取指操作的说明，EMRD、PCOE、IREN要有效，根据上面描述，选中该指令的第二行，将EMRD、PCOE、IREN、X2X1X0、AEN、S2S1S0都置成有效和相应的工作方式，此微指令的值为0CBFF90H。</p>
<p>“GOTO  MM”为无条件跳转，所要执行的操作为从EM中读出目标地址，送到数据总线DBUS上，并存入PC中，实现程序跳转。从EM中读数，EMRD要有效，读EM的地址由PC输出，PCOE有效，数据送到DBUS，EMEN要有效，将数据打入PC中，由两位决定，ELP有效，指令寄存器IR的第三位IR3应为1，由于本指令机器码为0CH，存入IR后，IR3为1。选中“GOTO  MM”指令的第一行，将上面的EMRD、PCOE、EMEN、ELP设成低，使其成为有效状态，结合指令的第三位，实现程序跳转，这条微指令的值为0C6FFFFH。下条微指令应为取指操作，微指令的值为0CBFFFFH。</p>
<p>“OUTA”，将累加器的内容输出到输出端口。其操作为累加器A不做运算，直通输出，ALU结果不移位输出到DBUS，DBUS上的数据存入输出端口OUT。累加器A直通输出结果，S2S1S0值要为111(二进制)，ALU结果不移位输出到数据总线DBUS，X2X1X0的值要等于100(二进制)，DBUS数据要打入OUT，那么OUTEN应有效。与此同时，ABUS和IBUS空闲，取指操作可以并行执行，也就是以PC为地址，从EM中读出下条将要执行指令的机器码，并打入IR和uPC中，根据取指操作的说明，EMRD、PCOE、IREN要有效，综上所述，选中此指令的第一行，将EMRD、PCOE、IREN、OUTEN、X2X1X0、S2S1S0置成有效状态和相应的工作方式，微指令的值为0CBDF9FH。</p>
<h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>实验所采用的开发板为Nexys4-DDR。它采用了Xilinx Artix-7 FPGA芯片，它是一款简单易用的数字电路开发平台，可以支持在课堂环境中来设计一些行业应用。大规模、高容量的FPGA, 海量的外部存储, 各种USB、以太网、以及其它接口, 这些让Nexys4-DDR 能够满足从入门级组合逻辑电路到强大的嵌入式系统的设计。同时，板上集成的加速度、温度传感器，MEMs数字麦克风，扬声器放大器以及大量的I/O设备，让Nexys4-DDR不需要增添额外组件而用于各种各样的设计。</p>
<p>实验设计主要代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library IEEE;</span><br><span class="line">use IEEE.STD_LOGIC_1164.ALL;</span><br><span class="line"></span><br><span class="line">entity Switch_LEDs is</span><br><span class="line">    Port ( switch_0 : in STD_LOGIC;</span><br><span class="line">        switch_1 : in STD_LOGIC;</span><br><span class="line">        LED_0 : out STD_LOGIC;</span><br><span class="line">        LED_1 : out STD_LOGIC);</span><br><span class="line">end Switch_LEDs;</span><br><span class="line"></span><br><span class="line">architecture Behavioral of Switch_LEDs is</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">LED_0 &lt;= switch_0;</span><br><span class="line">LED_1 &lt;= switch_1;</span><br><span class="line">end Behavioral;</span><br></pre></td></tr></table></figure></div>

<p>约束文件如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_property PACKAGE_PIN J15 [get_ports switch_0] </span><br><span class="line">set_property PACKAGE_PIN L16 [get_ports switch_1] </span><br><span class="line">set_property PACKAGE_PIN H17 [get_ports LED_0] </span><br><span class="line">set_property PACKAGE_PIN K15 [get_ports LED_1] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports switch_0] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports switch_1] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports LED_0] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports LED_1]</span><br></pre></td></tr></table></figure></div>

<h3 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h3><p>实验记录为首先会看到Nexys4- DDR 上表示烧写完成的Done 指示会点亮，接着拨动SW0，LD0指示灯亮，LD1指示灯不亮。恢复SW0,拨动SW1，LD0指示灯不亮，LD1指示灯亮。同时拨动SW0和SW1，可以看到LD0和LD1都会亮，将SW0和SW1恢复，则LD0和LD1指示灯都不亮。</p>
<h3 id="总结体会"><a href="#总结体会" class="headerlink" title="总结体会"></a>总结体会</h3><p>FPGA是一个可编程芯片，在一块较小的电路板上就能完成很多操作，同时上面还有多种数据线接口，能够实现较为复杂和多样的测试，同时上面还有温度传感器，和印象中的芯片有很多不一样。</p>
<p>FPGA 器件属于专用集成电路中的一种半定制电路，是可编程的逻辑列阵，能够有效的解决原有的器件门电路数较少的问题。FPGA 的基本结构包括可编程输入输出单元，可配置逻辑块，数字时钟管理模块，嵌入式块RAM，布线资源，内嵌专用硬核，底层内嵌功能单元。<br>通过对FPGA电路的学习和实验，我对计算机组成原理的课程有了更深的认识，同时，它以一种简洁，快速的方式展现了软件的编程是如何在计算机的内部运行并发挥作用的，就如同一座桥连通了软件编程和硬件的功能。通过编写设计文件和约束文件，用USB输入给电路板，即可在硬件上体现出软件设计的功能。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>前期，我学习了计算机组成原理这门课程，在学习中，掌握了一些基础理论，但是实践才是检验真理的唯一标准，通过这几次实验，我才真正理解计算机的基本组成与工作原理，了解计算机的内部运行机理，掌握计算机系统设计的基本技术，更重要的是通过实验培养了我们独立分析、解决问题的能力。</p>
<p>这几次实验使我对单处理机系统的组成和工作原理、并行体系结构有了更深刻的了解和认识。这对于建立整机概念，研究各功能部件的相互连接与相互作用，进行各功能部件的逻辑设计，都有很大的帮助。我掌握寄存器器件和寄存器组的工作原理，了解COP2000模型机所用主要寄存器的位置、作用、数据通路及控制信号;了解运算器模块如何连接以及数据通路;领会了课堂教学中关于ALU的功能特性的知识;学会用CPLD实现运算器。掌握运算器核心器件ALU的输出连入数据总线前常见处理方法;掌握控制器的工作原理;掌握由控制器、运算器、存储器、组成的模型机的工作原理;通过运行各种简单程序，掌握机器指令和微指令的关系等等。我很珍惜这次在实验中的思考与感悟，并且以后也会多多接触计算机组成原理的相关知识，拓宽自己的知识面。</p>
]]></content>
  </entry>
  <entry>
    <title>通信概论之调幅及恒比码</title>
    <url>/2020/12/29/introduction-to-communication/</url>
    <content><![CDATA[<h3 id="关于AM四种方法的探究与分析"><a href="#关于AM四种方法的探究与分析" class="headerlink" title="关于AM四种方法的探究与分析"></a>关于AM四种方法的探究与分析</h3><h4 id="关于调幅"><a href="#关于调幅" class="headerlink" title="关于调幅"></a>关于调幅</h4><p>调幅（Amplitude Modulation，AM），也就是通常说的中波，范围在530—1600KHz。调幅是用声音的高低变为幅度的变化的电信号。传输距离较远，但受天气因素影响较大，适合省际电台的广播。早期VHF频段的移动通信电台大都采用调幅方式，由于信道衰落会使模拟调幅产生附加调幅，造成失真，在传输的过程中也很容易被窃听，目前已很少采用。目前在简单通信设备中还有采用，如收音机中的AM波段就是调幅波，音质和FM波段调频波相比较差。</p>
<h4 id="调幅的分类"><a href="#调幅的分类" class="headerlink" title="调幅的分类"></a>调幅的分类</h4><p>振幅调制可分为普通调幅（AM），双边带调幅（DSB-AM），单边带调幅（SSB-AM）与残留边带调幅（VSB-AM）几种不同方式。</p>
<h4 id="调幅电路"><a href="#调幅电路" class="headerlink" title="调幅电路"></a>调幅电路</h4><p>调幅是使载波信号的幅度随着调制信号的幅度变化，载波的频率和相应不变。能够完成调幅功能的电路就叫调幅电路或调幅器。<br>调幅电路原理主要分为两类：高电平调幅电路和低电平调幅电路。</p>
<p>高电平调幅要求电路的输出功率足够大。电路在调幅的同时，还进行功率放大。调制过程通常是在丙类放大级进行的。根据调制信号控制的电极不同，调制方法主要有集电极调幅、基极调幅、发射极调幅。</p>
<h3 id="关于恒比码的思考与探索"><a href="#关于恒比码的思考与探索" class="headerlink" title="关于恒比码的思考与探索"></a>关于恒比码的思考与探索</h3><h4 id="恒比码的概念"><a href="#恒比码的概念" class="headerlink" title="恒比码的概念"></a>恒比码的概念</h4><p>在每个字符或功能信号中使用的各类码元均具有指定数目的检错码。在采用恒比码编码的体系中，所有有效的编码中为1的位都相同，所以被称为恒比。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/introduction-to-communication/constant_ratio_code.png"
                      alt="恒比码" title="恒比码"
                ></p>
<h4 id="恒比码的种类"><a href="#恒比码的种类" class="headerlink" title="恒比码的种类"></a>恒比码的种类</h4><p>常用的恒比码有两种，一种是7中取3码，即一个代码的7个码元中恒定保持3个1，4个0的比例，另一种是8中取4。这两种恒比码检错的基本原理都是相同的。<br>采用7中取3码时，全部比特均编成具有7个码元的代码，但其中只有7!/3!/4!个代码字符是可用的。<br>7中取3码能检出全部单个错误，这是因为单个错误使代码中的1的个数为2或4个，成为非法码而被检出来。同理，对于奇数个错误可检出，但对偶个数错误却不能全部检出。<br>在国际上通用的ARQ电报通信系统采用了7中取3定比码。这种编码的不足之处是必须增加把字符编码转换为恒比码的设备。</p>
<h4 id="恒比码的作用"><a href="#恒比码的作用" class="headerlink" title="恒比码的作用"></a>恒比码的作用</h4><p>能检测出全部奇数位错以及部分偶数位错，但码字中1变成0和0变成1成对出现的差错除外。简单，适用于用来传输电传机或其他键盘设备产生的字母和符号。因为每个汉字是以四位十进制数来代表的，所以提高十进制数字传输的可靠性，就等于提高汉字传输的可靠性。实践证明，采用这种码后，我国汉字电报的差错率大为降低。</p>
<h4 id="恒比码的出现原因"><a href="#恒比码的出现原因" class="headerlink" title="恒比码的出现原因"></a>恒比码的出现原因</h4><p>我认为在信号传输中，编码和解码方式灵活多样，同时加上码间串扰，使得解码的正确率有所偏差。此时，我们需要一种方式能够方便并且较为准确地帮助我们来判断解码地正确性，恒比码作为方法中的一种，也应运而生。由于恒比码中1的数目和0的数目之比保持恒定，只需要检测接收码组中1的数目是否对，就可知道有无错误，所以检验方式较为便捷，由此发展起来，得到了广泛应用。</p>
<h4 id="恒比码的发展"><a href="#恒比码的发展" class="headerlink" title="恒比码的发展"></a>恒比码的发展</h4><p>我认为恒比码作为一种检错码，可以很好的应用于信号传输时的检错，在信号传输正确性及效率方面有着独特的作用。而未来通信的检错发展，应该是检错效率高，正确性也较高的趋势，恒比码作为检错码，虽有着自己的检错方式，差错率也相应降低，但随着人们需求的扩张，必将出现检错效率更高的检错方式来代替恒比码，或者恒比码完善自己的种类，来适应不同情况下的信号检错，这样通信方面信号传输的正确率才会大大提高，从而适应未来通信发展的潮流。</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构实验</title>
    <url>/2020/12/26/data-struct-research/</url>
    <content><![CDATA[<h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>进行集合运算，用线性表存储集合数据，并完成集合运算，至少包括集合的交集、并集、补集、差集。</p>
<h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先分配内存空间，对线性表进行初始化，然后在线性表中插入元素e    。创建单链表的各节点，建立单链表。判断两元素是否相等，若相等则返回TRUE，否则返回FAISE。在顺序线性表L中查找第1个值与e满足compare()的元素的位。接着打印顺序表函数。编写函数实现两个集合的并运算，把数组A中各个元素先保存在数组C中。将数组B中的元素逐一与数组A中的元素进行比较，把不相同的元素添加到数组C中，数组C便是集合A和集合B的并集，编写函数实现两个集合的交运算，把数组A中元素逐一与数组B中的元素进行比较，将相同的元素放在数组C中，数组C便是集合A和集合B的交集。编写函数实现两个集合的差运算，将数组A中的元素逐一与数组B中的元素进行比较，把数组A与数组B不同的元素保存在数组C中，数组C便是集合A和集合B的差集。编写函数实现两个集合的补集运算。将数组E中的元素逐一与数组A中的元素进行比较，把不相同的元素保存到数组C中，数组C便是集合A关于集合E的补集。编写函数实现输入集合，选择操作等，最后进行实验结果的测试。</p>
<p>编写函数实现两个集合的并运算。把数组A中各个元素先保存在数组C中。将数组B中的元素逐一与数组A中的元素进行比较，把不相同的元素添加到数组C中，数组C便是集合A和集合B的并集。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void union(SqList La,SqList Lb,SqList &amp;Lc)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	ElemType elem;</span><br><span class="line">	Lc.length=0;</span><br><span class="line">	for(i = 0; i &lt; La.length; i++)</span><br><span class="line">	Lc.elem[Lc.length++]=La.elem[i];</span><br><span class="line">	for(i = 1; i &lt;= Lb.length; i++)&#123;</span><br><span class="line">		elem = Lb.elem[i-1];</span><br><span class="line">		if(!LocateElem_Sq(La,elem,Equal))</span><br><span class="line">		ListInsert_Sq(Lc,Lc.length+1,elem);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编写函数实现两个集合的交运算。把数组A中元素逐一与数组B中的元素进行比较，将相同的元素放在数组C中，数组C便是集合A和集合B的交集。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void same(SqList La,SqList Lb,SqList &amp;Lc)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	ElemType elem;</span><br><span class="line">	Lc.length = 0;</span><br><span class="line">	for(i = 1; i &lt;= La.length; i++)&#123;</span><br><span class="line">		elem = La.elem[i-1];</span><br><span class="line">		if(LocateElem_Sq(Lb,elem,Equal))</span><br><span class="line">		ListInsert_Sq(Lc,Lc.length+1,elem);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h4><p>实现栈和队列的基本操作，并进行算术表达式求值：利用栈实现一个中缀表达式的求值。</p>
<h4 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先初始化操作数栈，并进行操作数的进栈出栈，得到操作数栈的栈顶元素并打印，接着打印操作符中元素。初始化操作符栈，并进行操作符的进栈出栈，得到操作符栈顶元素。然后编写函数求表达式的长度，并判断操作符栈是否为空，接着判断符号优先级。编写函数实现四则运算并判断表达式是否符合四则运算。编写函数，输入表达式，并对相应的表达式进行计算，从而实现中缀表达式的求值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">double calculate()&#123;</span><br><span class="line">    double a, result=0,x, y, b;</span><br><span class="line">    int i=0，j=0,k=0; //i，i为循环变最</span><br><span class="line">    char ch,s[100] ;</span><br><span class="line">    Node p1;//操作符栈</span><br><span class="line">    Stack p2;//操作数栈</span><br><span class="line">    InitStack (&amp;p2);</span><br><span class="line">    InitNode(&amp;p1);</span><br><span class="line">    printf(&quot;输入表计式(输入’#’代麦结束)\n&quot;) ;</span><br><span class="line">    gets(s) ;</span><br><span class="line">    while(s[i]!=&#x27;\0’&amp;&amp;i&lt;Length(s))&#123;</span><br><span class="line">        k=0;</span><br><span class="line">        b=0;</span><br><span class="line">        a=0;</span><br><span class="line">        j=i;</span><br><span class="line">        if(s[j&gt;=’O’&amp;&amp;s[j]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">            while(s[j]&gt;=&#x27;0&#x27;&amp;&amp;s[j]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">                a=(double)((s[j]-&#x27;0’)+a*10);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[j]==’.&#x27;)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                if(s[j]&gt;=&#x27;0’&amp;&amp;s[j]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">                   while(s[j]&gt;=’O&#x27;&amp;&amp;s[j]&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">                        b=(double)((s[j]-&#x27;0’)+b*10) ;</span><br><span class="line">                        k++;</span><br><span class="line">                        j++；</span><br><span class="line">                   &#125;</span><br><span class="line">                   for(i=0;i&lt;k;i++)&#123;</span><br><span class="line">                        b=b/(10.0);</span><br><span class="line">                        a=a+b;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i=--j;</span><br><span class="line">                PushStack (&amp;p2, a);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(Isop(s[i])==1)&#123;</span><br><span class="line">            if(empty (&amp;p1))&#123;</span><br><span class="line">                PushNode (&amp;p1,sli]）;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                while( ! empty(&amp;p1))&#123;</span><br><span class="line">                    ch=getTopNode(&amp;p1);</span><br><span class="line">                    if(compare(ch)&gt;=compare(s[i]))&#123;</span><br><span class="line">                        x=PopStack(&amp;p2);</span><br><span class="line">                        y=PopStack(&amp;p2);</span><br><span class="line">                        result=add(y,ch, x) ;</span><br><span class="line">                        PopNode (&amp;p1);</span><br><span class="line">                        PushStack (&amp;p2,result) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(s[i]!=’#’)</span><br><span class="line">                    PushNode(&amp;p1,s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(Isop(s[i])==2)&#123;</span><br><span class="line">            if(s[i]==&#x27;()&#123;</span><br><span class="line">               PushNode(&amp;p1,s[i]);</span><br><span class="line">            else&#123;</span><br><span class="line">                while(getTopNode(&amp;p1)!=’(’)&#123;</span><br><span class="line">                      ch=getTopNode(&amp;p1) ;</span><br><span class="line">                      x=PopStack(&amp;p2) ;</span><br><span class="line">                      y=PopStack (&amp;p2);</span><br><span class="line">                      result=add(y, ch,x);</span><br><span class="line">                      PopNode(&amp;p1) ;</span><br><span class="line">                      PushStack (&amp;p2,result);</span><br><span class="line">                      &#125;</span><br><span class="line">                      PopNode(&amp;p1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line">    while(! empty(&amp;p1))&#123;</span><br><span class="line">        ch=getTopNode(&amp;p1) ;</span><br><span class="line">        x=PopStack (&amp;p2);</span><br><span class="line">        y=PopStack (&amp;p2);</span><br><span class="line">        result=add(y,ch,x) ;</span><br><span class="line">        PopNode(&amp;p1);</span><br><span class="line">        PushStack(&amp;p2, result) ;</span><br><span class="line">    &#125;</span><br><span class="line">    return getTopStack(&amp;p2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h3><h4 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h4><p>使用树结构存储医院楼房结构，通过读取文件definition.txt文件创建树形结构，将树形结构创建后，可以读取queries.txt中的查询完成对应的操作。查询有几个子部件并且按照一定顺序打印出来。</p>
<h4 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>使用结构体分别定义节点与树结构，用数组储存所有节点，始化节点和树结构后，可以进行创建树的操作。创建树结构后，使用递归的方法实现查找父节点和查找孩子节点的函数。根据文件读入的信息以及查找函数的遍历操作，对计算结果进行输出。<br>编写函数利用递归实现查找父节点:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void searchFatherNode(treeNode* node, char name[50], treeNode* &amp;mark)&#123;</span><br><span class="line">	if(node == NULL)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(mark != NULL)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(strcmp(name, node-&gt;name) == 0)&#123;</span><br><span class="line">		mark = node;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">		searchFatherNode(node-&gt;childNode[i], name, mark);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="图结构的应用"><a href="#图结构的应用" class="headerlink" title="图结构的应用"></a>图结构的应用</h3><h4 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h4><p>通过读取文件存储图中的数据，并完成图基本操作。输入起始城市和终点城市，可以给出两个城市的最小费用路线，并将路线给出。</p>
<h4 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>使用三个结构体分别定义图的矩阵存储，权重以及最短路径。其中图结构中有顶点表，真实边数，真实顶点数，矩阵，权重结构体中存有距离和费用，最短路径中存有路径和费用。首先初始化邻接矩阵，存储地点的下表，对应行和列，来实现矩阵的赋值。初始化完成后，开始创建有向网。有向网创建成功后，输出结果进行打印。在求两个城市的最小费用路线时，利用迪杰斯特拉算法，得到的信息存储在最短路径结构体中，以便于后续对于最短路径的输出打印。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct weight&#123;</span><br><span class="line">    int distance;//距离</span><br><span class="line">    int price;//费用</span><br><span class="line">&#125;Weight;//权值</span><br><span class="line"></span><br><span class="line">typedef struct graph&#123;</span><br><span class="line">    //VerTexType vexs[Max_Tex_Num];</span><br><span class="line">    char vexs[Max_Tex_Num][50];//顶点表（字符串类型数组)</span><br><span class="line">    int vexnum;//真实顶点数</span><br><span class="line">    int edgenum;//真实边数</span><br><span class="line">    Weight arcs[Max_Tex_Num][Max_Tex_Num];//矩阵/////</span><br><span class="line">&#125;AMGraph;//邻接矩阵</span><br><span class="line"></span><br><span class="line">struct shortestPath&#123;</span><br><span class="line">    int path;</span><br><span class="line">    int money;</span><br><span class="line">&#125;dij[Max_Tex_Num];</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>操作系统实验思考</title>
    <url>/2021/06/20/operating-system/</url>
    <content><![CDATA[<h2 id="进程-线程的同步与互斥"><a href="#进程-线程的同步与互斥" class="headerlink" title="进程/线程的同步与互斥"></a>进程/线程的同步与互斥</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>进程间的相互制约有直接制约和间接制约两种不同的方式。</p>
<p>在生产者与消费者问题中，生产者不断的向缓冲区中写入数据，而消费者则从缓冲区中读取数据。生产者进程和消费者对缓冲区的操作是互斥，即当前只能有一个进程对这个缓冲区进行操作，生产者进入操作缓冲区之前，先要看缓冲区是否已满，如果缓冲区已满，则它必须等待消费者进程将数据取出才能写入数据，同样的，消费者进程从缓冲区读取数据之前，也要判断缓冲区是否为空，如果为空，则必须等待生产者进程写入数据才能读取数据。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者只能才能消费，它们还是同步关系。</p>
<p>经思考，我决定采用信号量机制进行进程之间的通信，设置两个信号量，空的信号量和满的信号量。使用信号量机制可以实现进程之间的同步和互斥，允许并发进程一次对一组信号量进行相同或不同的操作。在进程终止时，系统可根据需要自动消除所有被进程操作过的信号量的影响。</p>
<h3 id="解决过程与分析"><a href="#解决过程与分析" class="headerlink" title="解决过程与分析"></a>解决过程与分析</h3><ol>
<li>编写信号量方法<br>信号量方法里主要目的是编写P操作方法和V操作方法。用synchronized修饰同步方法，保证A线程执行该方法的时候，其他线程只能在方法外等着。在P操作方法中，利用wait()方法，使得当缓冲区已满/空时，生产者或消费者线程停止自己的执行，释放锁，使自己处于等待状态，让其它线程执行。在V操作方法中，利用notify()方法，当生产者或消费者向缓冲区放入或取出一个产品时，向其他等待的线程发出通知，同时释放锁，使自己处于等待状态，让其它线程执行。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Semaphore</span><br><span class="line">&#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public Semaphore(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">    //P操作</span><br><span class="line">    public synchronized final void P()&#123;</span><br><span class="line">        value--;</span><br><span class="line">        if(value&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;catch(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //V操作</span><br><span class="line">    public synchronized final void V()</span><br><span class="line">    &#123;</span><br><span class="line">        value++;</span><br><span class="line">        if(value&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            this.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>编写生产者方法<br>利用Runnable接口创建新进程，Runnable接口可以被任何想要被一个线程运行的接口继承实现。利用empty()方法获取空缓冲区单元，接着用mutex.P()进入临界区，用mutex.V()离开临界区并释放信号量，离开时满缓冲区数要加1。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Producer implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        Global.timingwait();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;  生产出一个商品&quot;);</span><br><span class="line">        Global.empty.P();//获取空缓冲区单元</span><br><span class="line">        Global.mutex.P();//进入临界区</span><br><span class="line">        Global.timingwait();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;  将产品放入缓冲区--缓冲区剩余 &quot; + (++Global.count) + &quot; 个产品&quot;);</span><br><span class="line">        Global.mutex.V();//离开临界区，释放信号量</span><br><span class="line">        Global.full.V();//满缓冲区数加一</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>编写消费者方法<br>利用full.P()方法获取满缓冲区单元，然后利用mutex.P()进入临界区，从缓冲区中取出产品后，利用mutex.V()离开临界区，释放互斥信号量，并利用empty.V()将空缓冲区加1。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Consumer implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        Global.timingwait();</span><br><span class="line">        Global.full.P();//获取满缓冲区单元</span><br><span class="line">        Global.mutex.P();//进入临界区</span><br><span class="line">        Global.timingwait();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;  从缓冲区取出一个产品--缓冲区剩余 &quot;+ (--Global.count) + &quot; 个产品&quot;);</span><br><span class="line">        Global.mutex.V();//离开临界区，释放互斥信号量</span><br><span class="line">        Global.empty.V();//空缓冲区加一</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;  消费一个商品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="调试问题及解决方案"><a href="#调试问题及解决方案" class="headerlink" title="调试问题及解决方案"></a>调试问题及解决方案</h3><p>需要注意对缓冲区大小为n的处理，当缓冲区中有空时，便可对empty变量执行P操作，一旦取走一个资源便可执行V操作以释放空闲区。对empty和full变量的P操作必须放在mutex的P操作之前。</p>
<h3 id="创新部分及思考"><a href="#创新部分及思考" class="headerlink" title="创新部分及思考"></a>创新部分及思考</h3><p>为了更加直观地表示出运行结果，我们在生产者将商品放入缓冲区，以及消费者从缓冲区内拿到商品后，利用Global(count)显示出缓冲区剩余的商品数，这样能更加清晰地显示出生产者和消费者在进行操作后缓冲区的变化。</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>按优先权调度算法实现处理器调度的程序：<br>假定系统有五个进程，每一个进程用一个进程控制块 PCB 来代表。在每次运行你所设计的处理器调度程序之前，为每个进程任意确定它的“优先数” 和“要求运行时间”。为了调度方便，把五个进程按给定的优先数从大到小连成队列。用一单元指出队首进程，用指针指出队列的连接情况。处理器调度总是选队首进程运行。采用动态改变优先数的办法，进程每运行一次优先数就减“1”。</p>
<p>按时间片轮转法实现处理器调度的程序：<br>有两种状态，“就绪”和“结束”，初始状态都为“就绪”，用“R”表示。 当一个进程运行结束后，它的状态为“结束”，用“E”表示。每次运行所设计的处理器调度程序前，为每个进程任意确定它的“要求运行时间”。把五个进程按顺序排成循环队列，用指针指出队列连接情况。另用一标志单元记录轮到运行的进程。</p>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>需要将逻辑地址转换为对应的页号以及页内位移，构造数组table进行逻辑地址的记录。<br>可假设有三种状态，“就绪”状态（ready）、“运行”状态（working）和 “结束”状态（finish）。五个进程的初始状态都为“就绪”，用“R”表示；当进程运行结束后，它的状态为“结束”，用“E”表示；当进程被选中开始运行但尚未结束时，它的状态为“运行”，用“W”表示。 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Priority &#123;</span><br><span class="line">    public static void getMax(Queue&lt;PCB&gt; queue) &#123;</span><br><span class="line">        //找出优先级最高（优先级数最小）的进程</span><br><span class="line">        int minPriorityNum = 100;</span><br><span class="line">        int minArrivalTime = 100;</span><br><span class="line">        for(PCB q : queue ) &#123;</span><br><span class="line">            if(q.getPriorityNum() &lt; minPriorityNum) &#123;</span><br><span class="line">                minPriorityNum = q.getPriorityNum();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出优先级最高且到达时间最早的进程</span><br><span class="line">        for(PCB q : queue ) &#123;</span><br><span class="line">            if(q.getPriorityNum() == minPriorityNum &amp;&amp; q.getArrivalTime() &lt; minArrivalTime) &#123;</span><br><span class="line">                minArrivalTime = q.getArrivalTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PCB first = queue.peek();</span><br><span class="line">        for(int i = 0;i &lt; queue.size();i++) &#123;</span><br><span class="line">            while(queue.peek().getPriorityNum() &gt; minPriorityNum) &#123;</span><br><span class="line">                queue.offer(queue.peek());</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            PCB q =  ((LinkedList&lt;PCB&gt;) queue).get(i);</span><br><span class="line"></span><br><span class="line">            if(!q.equals(first)) &#123;</span><br><span class="line">                if((q.getPriorityNum() == queue.peek().getPriorityNum()) &amp;&amp; q.getArrivalTime() &lt; queue.peek().getArrivalTime()) &#123;</span><br><span class="line">                    while(queue.peek().getArrivalTime() != minArrivalTime) &#123;</span><br><span class="line">                        queue.offer(queue.peek());</span><br><span class="line">                        queue.remove(queue.peek());</span><br><span class="line">                        queue.remove(0);</span><br><span class="line">                        //i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>每次运行所设计的处理器调度程序前，为每个进程任意确定它的“要求运行时间”。 在实际的系统中，当一个进程被选中运行时，必须置上该进程可以运行的 时间片值，以及恢复进程的现场，让它占有处理器运行，直到出现等待事件或运行满一个时间片。在这时省去了这些工作，仅用“已运行时间+1”来表示进程已经运行满一个时间片。程运行一次后，应把该进程的进程控制块中的指针值送到标志单元，以指示下 一个轮到运行的进程。同时，应判断该进程的要求运行时间与已运行时间，若该进程的要求 运行时间¹已运行时间，则表示它尚未执行结束，应待到下一轮时再运行。若该进程的要求 运行时间=已运行时间，则表示它已经执行结束，应指导它的状态修改成“结束”（E）且退出队列。此时，应把该进程的进程控制块中的指针值送到前面一个进程的指针位置。 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void RRAlgorithm() &#123;</span><br><span class="line">        mReadyQueue.add(mUnreachQueue.poll());</span><br><span class="line">        Process currProcess = mReadyQueue.poll();</span><br><span class="line">        //第一个进程执行</span><br><span class="line">        int currTime = executeProcess(currProcess, 0);</span><br><span class="line"></span><br><span class="line">        while(!mReadyQueue.isEmpty() || !mUnreachQueue.isEmpty()) &#123;</span><br><span class="line">            //把所有“到达时间”达到的进程加入运行队列头部</span><br><span class="line">            while(!mUnreachQueue.isEmpty()) &#123;</span><br><span class="line">                if(mUnreachQueue.peek().getArrivalTime() &lt;= currTime) &#123;</span><br><span class="line">                    mReadyQueue.add(mUnreachQueue.poll());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(currProcess.getRemainServiceTime() &gt; 0) mReadyQueue.add(currProcess);</span><br><span class="line">            //运行队列不为空时</span><br><span class="line">            if(!mReadyQueue.isEmpty()) &#123;</span><br><span class="line">                currProcess = mReadyQueue.poll();</span><br><span class="line">                currTime = executeProcess(currProcess, currTime);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当前没有进程执行，但还有进程为到达，时间直接跳转到到达时间</span><br><span class="line">                currTime = mUnreachQueue.peek().getArrivalTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="实验结果总结"><a href="#实验结果总结" class="headerlink" title="实验结果总结"></a>实验结果总结</h3><p>优先权调度算法：优先级可以是静态赋予：创建任务的时候，就指定优先级大小，并且保持不变，直到任务结束。也可以是动态赋予：优先级在执行任务中动态改变。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟中断降低当前进程的优先级。</p>
<p>时间片轮转法的性能很大程度上依赖于时间片的大小。如果时间片足够大，那么它就退化为先来先服务调度算法；若时间片很小，则处理机将在进程间过于频繁地切换，使处理机开销过大。</p>
<p>在平时中，我们可以把不同的任务划分为不同的优先级，然后在相同优先级的任务中使用时间片轮转。</p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>分页式虚拟存储系统是把作业信息的副本存放在磁盘上，当作业被选中时，可把 作业的开始几页先装入主存且启动执行。为此，在为作业建立页表时，应说明哪些页已在主存，哪些页尚未装入主存。作业执行时，指令中的逻辑地址指出了参加运算的操作数存放的页号和单元号， 硬件的地址转换机构按页号查页表，若该页对应标志为“1”，则表示该页已在主存，这时根据关系式计算出出欲访问的主存单元地址。设计一个“地址转换”程序来模拟硬件的地址转换工作。当访问的页在主存时，则形成绝对地址，但不去模拟指令的执行，而用输出转换后的地址来代替一条指令的执行。</p>
<p>每访问一个地址时，首先要计算该地址所在的页的页号，然后查页表，判断该页是否在主存——如果该页已在主存，则打印页表情况；同时输出绝对地址。如果该页不在主存且页表已满，则按淘汰算法淘汰一页后调入所需的页（只将该页在页表中标志位进行修改），打印页表情况，逐个地址访问，直到所有地址访问完毕。</p>
<h3 id="解决过程-1"><a href="#解决过程-1" class="headerlink" title="解决过程"></a>解决过程</h3><p>将逻辑地址转换为对应的页号以及页内位移，构造数组table进行逻辑地址的记录。 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Yetable[] table = new Yetable[7];</span><br><span class="line">    table[0]=new Yetable(0,1,5,0,&quot;011&quot;);</span><br><span class="line">    table[1]=new Yetable(1,1,8,0,&quot;012&quot;);</span><br><span class="line">    table[2]=new Yetable(2,1,9,0,&quot;013&quot;);</span><br><span class="line">    table[3]=new Yetable(3,1,1,0,&quot;021&quot;);</span><br><span class="line">    table[4]=new Yetable(4,0,0,&quot;022&quot;);</span><br><span class="line">    table[5]=new Yetable(5,0,0,&quot;023&quot;);</span><br><span class="line">    table[6]=new Yetable(6,0,0,&quot;121&quot;);</span><br><span class="line">    int[] tihuan = new int[]&#123;0,1,2,3&#125;;</span><br><span class="line">    int yeno;</span><br><span class="line">    Scanner scan = new Scanner(System.in);</span><br><span class="line">    int dizhi;</span><br><span class="line">    int jueduidizhi;</span><br><span class="line">    int flag=0;</span><br><span class="line">    int a=0;</span><br><span class="line">    System.out.println(&quot;页号  &quot;+&quot;标志  &quot;+&quot;主存块号&quot;+&quot;修改标志&quot;+&quot;磁盘位置&quot;);</span><br><span class="line">    for(int j=0;j&lt;table.length;j++)&#123;</span><br><span class="line">        System.out.println(table[j].yeno+&quot;    &quot;+table[j].logo+&quot;    &quot;+table[j].kuaino+&quot;      &quot;+table[j].xiugai+&quot;      &quot;+table[j].home);</span><br><span class="line">    &#125;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        System.out.println(&quot;请输入要访问的页号:&quot;);</span><br><span class="line">        yeno = scan.nextInt();</span><br><span class="line">        System.out.println(&quot;请输入页号的页内地址:&quot;);</span><br><span class="line">        dizhi =scan.nextInt();</span><br><span class="line">        for(int i=0;i&lt;table.length;i++)&#123;</span><br><span class="line">            if(yeno==table[i].yeno)&#123;</span><br><span class="line">                a++;</span><br><span class="line">                if(table[i].logo==1)&#123;</span><br><span class="line">                    System.out.println(&quot;页号  &quot;+&quot;标志  &quot;+&quot;主存块号&quot;+&quot;修改标志&quot;+&quot;磁盘位置&quot;);</span><br><span class="line">                    for(int j=0;j&lt;table.length;j++)&#123;</span><br><span class="line">                        System.out.println(table[j].yeno+&quot;    &quot;+table[j].logo+&quot;    &quot;+table[j].kuaino+&quot;      &quot;+table[j].xiugai+&quot;      &quot;+table[j].home);</span><br><span class="line">                    &#125;</span><br><span class="line">                    jueduidizhi=table[i].kuaino*1024+dizhi;</span><br><span class="line">                    System.out.println(&quot;绝对地址:&quot;+jueduidizhi);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(flag==4)&#123;</span><br><span class="line">                        flag=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    table[i].logo=1;</span><br><span class="line">                    int m=tihuan[flag];</span><br><span class="line">                    table[m].logo=0;</span><br><span class="line">                    table[i].kuaino=table[m].kuaino;</span><br><span class="line">                    table[m].kuaino=0;</span><br><span class="line">                    tihuan[flag]=table[i].yeno;</span><br><span class="line">                    flag++;</span><br><span class="line">                    System.out.println(&quot;页号  &quot;+&quot;标志  &quot;+&quot;主存块号&quot;+&quot;修改标志&quot;+&quot;磁盘位置&quot;);</span><br><span class="line">                    for(int j=0;j&lt;table.length;j++)&#123;</span><br><span class="line">                        System.out.println(table[j].yeno+&quot;    &quot;+table[j].logo+&quot;    &quot;+table[j].kuaino+&quot;      &quot;+table[j].xiugai+&quot;      &quot;+table[j].home);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(a==0)&#123;</span><br><span class="line">            System.out.println(&quot;无此页号!&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="调度算法思考"><a href="#调度算法思考" class="headerlink" title="调度算法思考"></a>调度算法思考</h2><p>先进先出页面调度算法即FIFO。优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。类似于数据结构中的队列。在实现上，把调入内存的页面根据先后次序链接成队列，设置一个指针总是指向页面队列的第一个页面，若还有空闲页，直接入队，没有空闲页，每次把指针指向的第一个页面置换掉即可。</p>
<p>最近最少使用即LRU页面调度算法，是当有空闲页面时直接调入，没有空闲页面时，选择最近最长时间没有访问过的页面进行淘汰并将新页面调入，认为过去一段时间内未访问过的页面在之后的一段时间也不太可能会被访问。通常需要设置一个标记位来记录页面未被访问的次数，页满时选择标记位最大的一个页面淘汰。</p>
<p>先进先出页面调度算法性能不好，但实现简单，基于队列实现的，与进程运行的状态不协调，因为进程会经常访问某些页面，并且先进先出可能会出现belady现象，即可分配的物理块数增多但缺页次数可能不减反增。<br>最近最少未使用算法开销大，性能好，需要硬件支持，属于堆栈类算法，与程序运行规律比较一致，通常比先进先出更常用。</p>
<p>每个文件都有其对应的文件控制快（FCB）包含了对文件进行控制的名称、标识符、类型、位置、大小等属性，通过操作系统提供的文件管理系统可以对文件进行创建、删除、读、写等操作。文件都是存放在目录下的，常用的操作系统会使用树形的目录结构来实现多级目录和按名存取。</p>
]]></content>
  </entry>
  <entry>
    <title>赴冀鲁豫纪念馆社会实践有感</title>
    <url>/2021/02/26/social-practice-research/</url>
    <content><![CDATA[<h3 id="纪念实践"><a href="#纪念实践" class="headerlink" title="纪念实践"></a>纪念实践</h3><p>我于寒假中参加了此次社会实践，开展了“挖掘红色故事 追溯红色记忆”的主题活动。努力用心灵去体味菏泽人争取民族解放的血性，用脚步去丈量广大军民浴血奋战的足迹，用眼睛去发现菏泽科学发展的谋略，用手指去触摸菏泽跨越赶超的活力，用耳朵去倾听孩子们幸福的笑声。</p>
<p>冀鲁豫边区革命纪念馆于1998年4月在山东省菏泽市奠基，2000年5月建成开馆，集展厅、画馆、广场建设于一体。主体建筑由展厅和全景画馆组成。展厅分为序厅和星星之火、浴血抗日、逐鹿中原、革命儿女四个大厅，全面而又系统地反映了三、四十年代冀鲁豫边区党政军民，在中国共产党的领导下，不怕牺牲、前赴后继、不屈不挠、英勇奋进的革命精神。绘画、地面塑形和灯光音响相互交融，堪称国内一流。2020年6月5日，被评为山东省退役军人思想政治教育基地。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/social-practice-research/revolutionary_memorial_museum.png"
                      alt="冀鲁豫边区革命纪念馆" title="冀鲁豫边区革命纪念馆"
                ></p>
<p>红色基因激励人们写就壮丽篇章。一把把锈迹斑斑的大刀、一张张隐藏历史基因的照片、一段段发人深省的视频，深深吸引了我的注意。面塑作品 《把娃儿捂死吧》，讲述的是一个令人不堪回首的故事。</p>
<p>1939年5月11日，日军集结5000余人，兵分九路包围八路军115师和鲁西区委机关。陈光代市长命令部队迅速突围，危急时刻，有6个八路军战士跑到三区妇救会长刘克林家里说：“日军围了村子，赶快转移。”说完就往外跑。这时候炮弹已经打过来，妇救会长刘克林不容分说，领着6个战士和家人往外走，躲避到一个山洞里。她让战士躲进里面，自己和婆婆守在洞口，可是她九个月大的儿子突然大哭起来，怎么哄也哄不住。全家人被捕不要紧，可是6个战士就掩护不住了。她毅然对婆婆说：“娘，把娃儿捂死吧！”婆婆流着泪没有说话。刘克林用手把孩子的嘴捂住……直到敌人离去。</p>
<p>红三村、秦兴体……冀鲁豫边区革命纪念馆类似的英雄群体和个人还有很多很多。红色基因，是信仰的种子、制胜的密码、精神的归宿，激励着这里的人们在不同的时代写就着精彩壮丽的篇章。</p>
<p>炮火隆隆、硝烟纷飞、杀声震天……我在冀鲁豫边区革命纪念馆参观采访时，观看了郓城攻坚战全景画馆。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/social-practice-research/exhibition_of_revolutionary_history.png"
                      alt="革命史陈列" title="革命史陈列"
                ></p>
<p>坐在旋转平台的椅子上，只见眼前火光冲天，枪声、炮声、飞机轰鸣声、攻城厮杀声交织在一起，场景不断交替，真实再现了当年郓城攻坚战的壮观场景，让人倍感胜利来之不易。1947年夏，刘邓大军飞越黄河天险，千里挺进大别山，拉开了由战略防御转为战略进攻的序幕。1947年7月刘邓大军连续作战，连战连捷，先后解放郓城、曹县、定陶等县城，歼敌数万人。</p>
<p>一只陈旧的枣红色文件柜、一把油迹斑斑的罗圈椅，无不诉说着那段金戈铁马的战斗岁月。巨野县田庄镇丁官屯村一处普通的农家小院，是解放战争时期刘伯承、邓小平指挥鲁西南战役的指挥部旧址，目前刘邓首长住室和使用过的部分物品仍在此保存。</p>
<p>70年前，刘伯承、邓小平曾怀抱这处农家小院主人韩存政的女儿在这里休息嬉戏；70年后，这里已经辟为鲁西南战役的指挥部旧址。</p>
<p>70年前，刘邓大军与巨野人民携手作战、不怕牺牲、顽强拼搏，为全中国的解放事业作出了彪炳史册的历史贡献；70年后，百万巨野人民不忘革命精神，攻坚克难、锐意进取，积极投身经济社会建设中，努力建设繁荣富强、宜居宜业的美丽新巨野。</p>
<p>在巨野文庙，巍峨的大成殿和丰富的汉代文物让人不禁感叹巨野的悠久历史；在巨野县书画院，精彩的书画作品和麒麟雕塑彰显着巨野的文化底蕴；在巨野新巨龙能源有限公司，世界一流的千万吨矿井展示巨野的富饶；在花冠集团，点滴尽杰作的承诺展现了巨野人永无止境的进取精神。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/social-practice-research/the_first_flag.png"
                      alt="第一个国旗" title="第一个国旗"
                ></p>
<p>“这面狱中红旗源于罗广斌听到的一个消息。”红岩魂陈列馆内，王浩指着橱窗内展示的狱中红旗说。</p>
<p>1949年10月7日，虽然中华人民共和国已经成立7天，但由于国民党反动派封锁信息，被囚禁在白公馆看守所的罗广斌等人并未得知这一消息。</p>
<p>那天下午，罗广斌刚刚走出牢房，准备去放风，同狱的原东北军爱国将领黄显声叫住了他。</p>
<p>黄显声小声地对他说：“中华人民共和国已经于7天前在北京成立了，中华人民共和国的国旗是五星红旗，国歌是风靡抗战时期的《义勇军进行曲》……”放风结束后，罗广斌赶紧回到牢房，把这一喜讯分享给每一位同志。</p>
<p>“罗广斌带来的这一消息，让整个牢房沸腾了。”王浩说。据史料记载，与罗广斌同在一间牢房的王朴、陈然等难友听到这一喜讯，兴奋得几乎跳起来。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/social-practice-research/red_rock.png"
                      alt="红岩" title="红岩"
                ></p>
<p>重庆解放后，罗广斌与杨益言在创作小说《红岩》时，把制作狱中红旗这一情节进行了艺术地再现。</p>
<p>随着红岩精神的传承与发扬，这面红旗背后的故事也成为广大文艺工作者进行创作的重要题材。除了小说《红岩》外，革命志士绣红旗的场景还出现在电影《烈火中永生》等文艺作品中，特别是在重庆市川剧院编排的新版川剧《江姐》里，以黄色绸带舞再现绣红旗的情景更是让不少观众印象深刻。</p>
<p>通过这次去纪念馆参观，我缅怀了革命先烈的英雄事迹，深深体会到了中国革命的胜利来之不易。在以后学习生活中，我一定要更加珍惜美好的幸福生活，一定要以先辈们为榜样，勇挑重担，攻坚克难。 </p>
<h3 id="实践成果"><a href="#实践成果" class="headerlink" title="实践成果"></a>实践成果</h3><p>获得 “东北大学社会实践优秀个人” 奖项。</p>
]]></content>
  </entry>
  <entry>
    <title>git 常用命令总结</title>
    <url>/2021/12/01/git-basic-use/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了方便之后用 github 托管项目，整理了一些 git 基础的使用场景，后续可继续补充添加。</p>
<h3 id="github-更新"><a href="#github-更新" class="headerlink" title="github 更新"></a>github 更新</h3><p>为避免带有“种族歧视色彩”，从2020年10月1日起， 在 github 上创建的所有新的源代码仓库将默认被命名为 “main”，而不是原先的”master”。</p>
<h3 id="Git-本地项目与远端连接"><a href="#Git-本地项目与远端连接" class="headerlink" title="Git 本地项目与远端连接"></a>Git 本地项目与远端连接</h3><ol>
<li>本地新建 repo。</li>
<li>repo 文件夹中使用 git init 命令，之后文件夹中多出来一个 .git 文件夹。</li>
</ol>
<p>若之前与其他的远端建立关联，现在想断开，有两种方法。</p>
<ul>
<li>Git Bash Here 输入<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure></div></li>
<li>直接删除本地库 .git 文件夹。</li>
</ul>
<ol start="3">
<li>关联远程库。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url:如https://github.com&gt;</span><br></pre></td></tr></table></figure></div></li>
<li>将文件添加到暂存区。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></div></li>
<li>将文件提交至仓库<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;feat:/bugfix:&quot;</span><br></pre></td></tr></table></figure></div></li>
<li>git pull 获取远程库与本地合并<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure></div></li>
<li>将本地内容推送至远程<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="Git-克隆远端"><a href="#Git-克隆远端" class="headerlink" title="Git 克隆远端"></a>Git 克隆远端</h3><ol>
<li>克隆远端项目至本地<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com</span><br></pre></td></tr></table></figure></div></li>
<li>后续添加至暂存区、远端提交等操作相同。</li>
</ol>
<h3 id="Git-新建分支"><a href="#Git-新建分支" class="headerlink" title="Git 新建分支"></a>Git 新建分支</h3><ol>
<li>克隆项目，若想开发新需求，新建分支。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b newBranchName</span><br></pre></td></tr></table></figure></div></li>
<li>查看分支状态<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></div></li>
<li>切换到本地新分支<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout newBranchName</span><br></pre></td></tr></table></figure></div></li>
<li>提交至远端仓库<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin newBranchName</span><br></pre></td></tr></table></figure></div>
(之后提交前要先拉取)</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数据库基础知识总结</title>
    <url>/2021/03/31/mysql-basic/</url>
    <content><![CDATA[<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><ol>
<li>DB: 数据库，作为一组有组织的数据的容器。</li>
<li>DBMS：数据库管理系统，又称为数据库软件或产品，用于管理 DB 中的数据。</li>
</ol>
<ul>
<li>基于共享文件系统的 DBMS （Access）</li>
<li>基于客户机-服务器的 DBMS （Mysql、Oracle、SqlServer）</li>
</ul>
<ol start="3">
<li>SQL：结构化查询语言，用于和 DBMS 通信的语言。</li>
</ol>
<h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><ol>
<li>持久化数据到本地。</li>
<li>可以实现结构化查询，方便管理。</li>
</ol>
<h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ol>
<li>语法格式<br>SELECT 查询列表 FROM 表名；<br>查询列表可以是：表中的字段、常量值、表达式、函数。</li>
<li>常用基础查询总结<br>在使用对应库前需要使用：“use 库名;” 语句进入相应库。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入后边操作所需要的库</span><br><span class="line">USE myemployees;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>查找表中的单个字段<br>SELECT 字段名 FROM 表名;<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询myemployees库employees表中的last_name</span><br><span class="line">SELECT </span><br><span class="line">	last_name </span><br><span class="line">FROM </span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure></div></li>
<li>查询表中的多个字段<br>SELECT 字段名1，字段名2，字段名3 FROM 表名；<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询表employees中的last_name、 salary、 email </span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  salary,</span><br><span class="line">  email </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure></div></li>
<li>查询表中的所有字段<br>SELECT * FROM 表名；<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM  employees;</span><br></pre></td></tr></table></figure></div></li>
<li>查询常量值<br>SELECT 常量值；<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 100;</span><br><span class="line">SELECT &#x27;aqq&#x27;; #mysql中字符串和字符均可以用单引号。</span><br></pre></td></tr></table></figure></div></li>
<li>查询表达式<br>SELECT 表达式；<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 100*40;#执行后显示该语句运算的结果</span><br></pre></td></tr></table></figure></div></li>
<li>起别名<br>起别名的优点：<br>1、可提高可读性。<br>2、如果查询字段有重复的内容，使用别名可以区分开来。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式一:使用AS</span><br><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br><span class="line">#方式二:使用空格</span><br><span class="line">SELECT 100%98 结果;</span><br><span class="line">#查询salary然后起名为out put,由于out为关键字容易引起歧义建议加双引号。</span><br><span class="line">SELECT </span><br><span class="line">	salary &quot;out put&quot; </span><br><span class="line">FROM </span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure></div></li>
<li>去重：关键字DISTINCT<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询员工所属的部门编号</span><br><span class="line">SELECT DISTINCT </span><br><span class="line">  `department_id` </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure></div></li>
<li>+: 运算符</li>
</ul>
<ol>
<li>加号两边两个数都为数值型作加法运算；</li>
<li>加号两边有一个为字符串型，试图 将字符串型转化为数值型，转化成功进行加法运算，否则将字符串型转化为0然后运算;</li>
<li>只要加号两边有一个为NULL结果一定为NULL.<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 100+100;     #执行结果：200。</span><br><span class="line">SELECT &#x27;123&#x27;+90;    #执行结果：90</span><br><span class="line">SELECT null+89;     #执行结果：NULL</span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>字符串的连接：使用CONCAT()<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  CONCAT(last_name, first_name) AS 姓名 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure></div>
只要拼接的字段中有一个为NULL结果一定为NULL，可以使用IFNULL()函数,判断是否为NULL改变显示的内容。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#显示出表employees的first_name、last_name、commission_pct列，各个列之间用逗号连接，列头显示成OUT_PUT</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(</span><br><span class="line">    `first_name`,</span><br><span class="line">    &#x27;,&#x27;,</span><br><span class="line">    `last_name`,</span><br><span class="line">    &#x27;,&#x27;,</span><br><span class="line">    IFNULL(`commission_pct`,0)#由于commission_pct中存在NULL字段，为了防止输出出错使用IFNULL();函数判断输出。</span><br><span class="line">  ) AS OUT_PUT </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure></div>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3></li>
</ul>
<ol>
<li><p>语法格式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	查询列表</span><br><span class="line">FROM</span><br><span class="line">	表名</span><br><span class="line">WHERE</span><br><span class="line">	筛选条件;</span><br></pre></td></tr></table></figure></div></li>
<li><p>分类<br>(1)按条件表达式筛选：即按照条件运算符(&gt;,&lt;,=,&gt;=,&lt;=,&lt;&gt;[不等于]，)不等于也支持其它语言中的“!=”。<br>(2)按逻辑表达式筛选：即按照逻辑运算符(and or not),也支持其它语言中常用的(&amp;&amp; || !)。<br>(3)模糊查询：like,between （） and （）,in,is null,is not null。</p>
</li>
<li><p>例子</p>
<h4 id="条件表达式或逻辑表达式筛选"><a href="#条件表达式或逻辑表达式筛选" class="headerlink" title="条件表达式或逻辑表达式筛选"></a>条件表达式或逻辑表达式筛选</h4></li>
</ol>
<ul>
<li>查询employees表中工资大于12000的员工信息<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary &gt; 12000;</span><br></pre></td></tr></table></figure></div></li>
<li>查询employees表中部门编号不等于90的员工名和部门编号<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	department_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id &lt;&gt;90;</span><br></pre></td></tr></table></figure></div></li>
<li>查询employees表中工资在10000到20000之间的员工名，工资以及奖金<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary &gt;= 10000 </span><br><span class="line">AND </span><br><span class="line">	salary &lt;= 20000;	</span><br></pre></td></tr></table></figure></div></li>
<li>查询employees表中部门编号不在90到110之间，或者工资高于15000的员工信息<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">		department_id &lt; 90</span><br><span class="line">OR</span><br><span class="line">		department_id &gt; 110</span><br><span class="line">OR</span><br><span class="line">		salary &gt; 15000;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>like —— 一般和通配符搭配使用。</p>
<p>通配符有：</p>
<ul>
<li><p>% 任意多个字符，包括0个字符，但是%之间的查询有顺序问题，例如： “%P%b%” 的查询结果是满足P在前，b在后字段；</p>
</li>
<li><p>_ 任意单个字段；</p>
</li>
<li><p>ESCAPE转义字符，用来在用到”_“和”%“匹配符时转义；</p>
</li>
</ul>
<p>例子：</p>
<ol>
<li>like </li>
</ol>
<ul>
<li>从employees表中查询员工名中包含字符a的员工信息<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &quot;%a%&quot;;</span><br></pre></td></tr></table></figure></div></li>
<li>从employees表中查询员工名中第三个字符为e,第五个字符为a的员工名和工资<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &#x27;_ _e_a%&#x27;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol start="2">
<li>转义字符的使用</li>
</ol>
<ul>
<li>从employees表中查询员工名中第二个字符为_的员工名<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	last_name</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &#x27;_&amp;_%&#x27; ESCAPE &#x27;&amp;&#x27;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol start="3">
<li>between （）and （）<br>可以提高语句简洁度，包含临界值，相当于等号，但临界值顺序不可互换。</li>
</ol>
<ul>
<li>从employees表中查询员工编号在100到120之间的员工信息<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	//employee_id &gt;= 100 and employee_id &lt;= 120;</span><br><span class="line">	employee_id BETWEEN 100 AND 120;//上条语句的简洁表达</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol start="4">
<li>in—用于判断某字段的值是否属于in列表中的某一项。<br>特点：使用in提高语句简洁度；in列表的值类型必须一致或兼容。</li>
</ol>
<ul>
<li>从employees表中查询员工的工种编号是IT_PROD、AD_VP、AD_PRES中的一个员工名和编号<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	//job_id = &#x27;IT_PROD&#x27; or job_id = &#x27;AD_VP&#x27; or job_id = &#x27;AD_PRES&#x27;;</span><br><span class="line">	job_id IN(&#x27;IT_PROD&#x27;,&#x27;AD_VP&#x27;,&#x27;AD_PREs&#x27;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol start="5">
<li>is null 、is not null、安全等于&lt;=&gt;<br>&lt;&gt;或=不能用于判断null；<br>is null和is not null 可以判断是否为null；<br>is null和is not null仅可以判断null值，可读性高；<br>&lt;=&gt;(安全等于)既可以判断null，也可以判断普通数值类型，可读性较低。</li>
</ol>
<ul>
<li>从employees表中查询没有奖金的员工名和奖金率<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NULL;</span><br><span class="line">	//或commission_pct &lt;=&gt; NULL;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ol>
<li><p>语法格式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT    查询列表</span><br><span class="line">FROM      表名</span><br><span class="line">【WHERE  筛选条件】</span><br><span class="line">ORDER BY  排序列表  【asc升序 或 desc降序】</span><br><span class="line">//方括号中的内容为可选部分		</span><br></pre></td></tr></table></figure></div></li>
<li><p>注意事项<br>1、asc升序，desc降序，不写默认为升序。<br>2、order by 字句可以支持单个字段、多个字段、表达式、函数、别名。<br>3、order by子句一般是放在查询语句最后面(limit子句除外).</p>
</li>
<li><p>例子</p>
</li>
</ol>
<ul>
<li><p>查询员工信息，要求工资从高到低排序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary DESC;</span><br></pre></td></tr></table></figure></div></li>
<li><p>查询部门编号&gt;=90的员工信息，要求按入职时间先后进行排序【筛选条件】</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	*</span><br><span class="line">FROM	employees</span><br><span class="line">WHERE	department_id &gt;=90</span><br><span class="line">ORDER BY hiredate ASC;</span><br></pre></td></tr></table></figure></div></li>
<li><p>按年薪由高到低显示员工的信息和年薪【按表达式或别名排序】</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *,</span><br><span class="line">	salary*12*(1+IFNULL(commission_pct,0)) AS 年薪</span><br><span class="line">FROM	employees</span><br><span class="line">ORDER BY 年薪 DESC;</span><br></pre></td></tr></table></figure></div></li>
<li><p>按姓名的长度由短到长显示员工的姓名和工资,姓名长度【按函数排序】</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	</span><br><span class="line">	LENGTH(last_name) 姓名长度,</span><br><span class="line">	last_name,</span><br><span class="line">	selary</span><br><span class="line">FROM	</span><br><span class="line">	employees</span><br><span class="line">ORDER BY LENGTH(last_name) ASC;</span><br></pre></td></tr></table></figure></div></li>
<li><p>查询员工信息，要求先按照工资升序，再按照员工编号降序(即先按照工资升序排列，若是工资相同的，则按照编号降序)【按多个字段排序】</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	*</span><br><span class="line">FROM	employees</span><br><span class="line">ORDER BY salary ASC,</span><br><span class="line">		 employees_id DESC;</span><br></pre></td></tr></table></figure></div>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3></li>
<li><p>前提条件：两个表有联系，通过外键关联。</p>
</li>
</ul>
<ol>
<li>普通内连接<br>语法： 关键字 … inner join … on 条件；<br>注意：</li>
</ol>
<ul>
<li>在 inner join关键字之前写表1</li>
<li>在 inner join关键字以后写表2</li>
<li>on的后面写条件：（表1是dept，表2是emp）dept.did = emp.dno</li>
</ul>
<p>语句：select * from dept inner join emp on dept.did = emp.dno；</p>
<ol start="2">
<li>隐式内连接</li>
</ol>
<ul>
<li>语法：select…from 表1，表2 where 表1.字段 = 表2.字段；</li>
<li>语句：select * from dept，emp where dept.did = emp.dno；</li>
<li>别名：select * from dept d，emp e where d.did = e.dno；</li>
<li>指定字段：select d.dname，e.ename，e.sal from dept d，emp e where d.did = e.dno；</li>
</ul>
<ol start="3">
<li>多表查询之外连接</li>
</ol>
<p><strong>左外连接（左连接）</strong></p>
<ul>
<li>语法： …表1  left outer join 表2 on 表1.字段 = 表2.字段</li>
<li>语句：select * from dept left outer join emp on dept.did = emp.dno；</li>
<li>特点：看左表，默认把左表中全部数据都查询出来，再查询出有关联的数据。</li>
</ul>
<p><strong>右外连接（右连接）</strong></p>
<ul>
<li>语法：…表1  right outer join 表2 on 表1.字段 = 表2.字段</li>
<li>语句：select * from dept right outer join emp on dept.did = emp.dno；</li>
</ul>
<ol start="4">
<li>总结<br>1、笛卡尔积<br>两个结果的乘积，数据是重复，目的：去除掉重复的数据。<br>2、内连接和外连接的数据的区别<br>如果数据正常的话，不管是内连接和外连接，查询的结果都是一样的。</li>
</ol>
<ul>
<li>内连接查询的结果都是有关系的数据</li>
<li>左连接，先看SQL语句中哪个表是左表，把左表中的数据全部都查询出来，和有关系的数据也会查询出来。</li>
<li>右连接，先SQL语句中的那个表是右表，把右表中的数据全部查询出来，和有关系数据查询出来。</li>
</ul>
<p><strong>相关例子</strong></p>
<ul>
<li>内连接<br>select * from dept d，emp e where d.did = e.dno；<br>查询的结果都是主外键关联的数据</li>
<li>左连接<br>select * from dept left outer join emp on dept.did = emp.dno；<br>把左表中所有的数据全部都查询出来和有关联的数据</li>
<li>右连接<br>select * from dept right outer join emp on dept.did = emp.dno；<br>把右表中所有的数据全部都查询出来和有关联的数据</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ol>
<li>子查询，嵌套查询，一个select语句不能查询出结果的，可以通过多个select语句来查询结果。</li>
<li>例子：查询出英语成绩大于英语平均分的同学</li>
</ol>
<ul>
<li>先计算出英语的平均分（select avg（english）from stu；）</li>
<li>再编写select语句<br>select username，english from stu where english &gt;（select avg （english）from stu）；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络与实际生活的联系思考</title>
    <url>/2021/05/16/thinking-between-network-and-life/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们的日常生活中，网络几乎是不可或缺的一部分。而网络中经常出现的一些问题有的大家有很熟悉，以前没有深入的研究过，现在学习了计算机网络这门课程，可以从现有知识的角度来探讨一下这些问题背后的原因所在。</p>
<h2 id="网页打开速度差异"><a href="#网页打开速度差异" class="headerlink" title="网页打开速度差异"></a>网页打开速度差异</h2><p>就拿我们生活中的实例来说，经常会有在寝室中，大家都连的校园网，但是打开网页的速度却有明显差别的情况。可能别人的网页已经加载完毕，而自己的网页却还在加载中。导致这一情况出现的原因有很多，比如电脑本身问题。可能磁盘碎片从不整理，开机启动项过多，或者桌面文件非常多，电脑垃圾太多，这些都有可能导致加载过慢。从位置方面来说，可能加载快的电脑离信号发射源近一些，这样信号更强，受其他信号的干扰更少，所以速度会好的多。无线信号的干扰可能有WLAN网络自身的互干扰。对一个大的WLAN网络来说，尤其是高密度部署的网络，同一信道常常需要被不同AP使用。而这些AP之间存在着重复区域时，就存在互相干扰问题。如果同频AP之间不可见但覆盖区域有交集，则对处于交集区域的Client而言可能会形成隐藏节点或暴露节点问题。隐藏节点和暴露节点会产生两个方面的问题，其一是报文发送时需要退避或不断重传；其二是由于报文重传时会降低报文发送的物理速率，导致同一AP的影响范围扩大，也使得报文发送占用更多的空口时长，冲突几率加大，引起更多的重传。这样就会导致发送数据的效率不同，从而加载的速度也有所差异。其次，可能是因为电脑网卡和无线路由不兼容导致的。网卡是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收，帧的封装与拆封，介质访问控制，数据的编码与解码以及数据缓存的功能等。当网卡和无线路由不兼容时，会降低功能效率，影响到帧的发送和接受速度。有的时候还会短时间的出现连接上校园网但无法上网的情况，可能是因为无线路由器的DHCP出了问题，无法正常分配IP地址了。系统默认地给了一个IP地址，不过由于和无线路由器不是一个IP段，所以无法正常上网。</p>
<h2 id="页面找不到"><a href="#页面找不到" class="headerlink" title="页面找不到"></a>页面找不到</h2><p>我们在打开页面的时候，经常出现页面找不到的情况。常见的会出现“无法访问此网站”或“404 not found”这样的提示词。若显示无法访问此网站，有可能是因为国内不能访问国外受限网站导致的。也有可能是因为使用了http协议来访问了需要使用https协议访问的站点。</p>
<h3 id="ERR-NAME-RESOLUTION-FAILED"><a href="#ERR-NAME-RESOLUTION-FAILED" class="headerlink" title="ERR_NAME_RESOLUTION_FAILED"></a>ERR_NAME_RESOLUTION_FAILED</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/thinking-between-network-and-life/ERR_NAME_RESOLUTION_FAILED.png"
                      alt="DNS配置出错图" title="DNS配置出错图"
                ><br>当错误代码是”ERR_NAME_RESOLUTION_FAILED”或”ERR_CONNECTION_REFUSED”时，则可能DNS配置出现了问题。可能由于网站域名服务器故障或网站服务器有故障。另外也有一种情况是网络服务商的网络服务服务器出现故障，也会出现类似情况，主要由于线路堵塞导致，常见某个地方区域网站无法访问，具有区域性。虽然我们多数人上网都不会去设置DNS，一般都是采用自动获取，不过不少局域网都需要固定IP地址，选择固定IP地址，我们就需要输入DNS地址了，而DNS输入错误就会导致网页打不开。</p>
<h3 id="404-not-found"><a href="#404-not-found" class="headerlink" title="404 not found"></a>404 not found</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/thinking-between-network-and-life/404-not-found.png"
                      alt="404出错图" title="404出错图"
                ><br>404 not found，是HTTP对网页错误情况返回的一种状态码，当用户在浏览器中输入网址时，服务器会根据输入的地址判断是否有对应的网页信息，如果没有对应信息，说明用户输入的可能是一串无效的链接，服务器就会向用户返回404 not found状态码，告诉用户没有找到对应的网页信息。可能是由于更换了网站程序等存在找不到的现象，如网站更换服务器，部分静态文件没有复制到新的服务器上，或者是因为新服务器的文件夹权限问题导致文件没有读取权限，因此出现404 not found问题。也有可能是因为动态规则变更，导致页面出现404not found错误也比较常见。当一个动态页面因为伪静态规则变更，会有可能导致URL的变更，那么前面的URL将会失效，当我们规则变更以后还打开前面的URL自然会出现404not found错误提示。此外还可能是因为DNS设置阻止，这时我们需要使用代理浏览器才可以正常浏览。</p>
<h2 id="IP-地址冲突"><a href="#IP-地址冲突" class="headerlink" title="IP 地址冲突"></a>IP 地址冲突</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/thinking-between-network-and-life/ip-address-conflict.png"
                      alt="IP 地址冲突图" title="IP 地址冲突图"
                ><br>电脑接入网络后，会发送免费ARP(Gratuitous ARP)，向整个二层网络广播自己的IP地址与MAC地址信息，以便让别的终端学习，当A侦测到有终端广播的IP地址与自己一致时，电脑便会提示IP冲突了。当两个通信中端被分配两个相同的IP地址时，就会发生IP地址冲突。IP地址冲突发生在两个终端之间，会使其中一个或者他们两个都无法进行网络操作。造成这一现象的原因可能是因为系统管理员在一个LAN（局域网）中的两台电脑或设备上分配了同样的静态IP地址，或者系统管理员给一台电脑分配了一个在本地DHCP（动态主机配置协议）范围内的IP地址，相同的IP地址被本地DHCP服务器自动的分配给了本地主机。客户端收到服务器提供的IP地址后，会在整个局域网检测此IP是否被占用，手段就是最简单常用的PING。在同事网络环境，部分电脑开启了防火墙默认拒绝外部终端ping request。客户端检测此IP无法PING通，则会回复服务器接收此IP，于是出现IP冲突。也有可能是因为DHCP服务器发生故障使得将相同的IP地址自动分配给多个电脑。 IP地址冲突后，可以手动修改自己的IP地址，不过这种方法不适合在大型局域网中使用，只适合在很小的网络环境中采用。还可以利用交换机的端口把不同的部门隔离开来解决，这是因为利用交换机可以对不同的区域实行不同的管理，经过分割的网段之间互不干扰，可以在一定程度上解决IP地址冲突的问题。</p>
]]></content>
  </entry>
</search>
